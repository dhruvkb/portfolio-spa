/**
 * A class that implements one node in a file-system tree. Each node may either
 * be a file or a folder and may have children if it is a folder.
 */
class Node {
  /**
   * Create a new object of class Node.
   *
   * @constructor
   * @constructs {Node}
   *
   * @param {string} type - the type of Node this is in the filesystem
   * @param {string} name - the name of the Node
   * @param {string} alternativeName - an alias for the Node
   */
  constructor (type, name, alternativeName = undefined) {
    this.type = type

    this.name = name
    this.alternativeName = alternativeName || name

    this.parent = null
    this.children = []
  }
}

/**
 * A class that implements the FIFO queue data type for Node objects.
 */
class Queue {
  /**
   * Create a new object of class Queue.
   *
   * @constructor
   * @constructs {Queue}
   */
  constructor () {
    this.oldestIndex = 1
    this.newestIndex = 1

    this.storage = {}
  }

  /**
   * Get the number of remaining items in the queue.
   * @return {number} the number of items in the queue
   */
  size () {
    return this.newestIndex - this.oldestIndex
  }

  /**
   * Add the given Node to the end of the queue.
   * @param {Node} node - the last-in Node to add to the queue
   */
  enqueue (node) {
    this.storage[this.newestIndex] = node
    this.newestIndex++
  }

  /**
   * Get the Node from the start of the queue.
   * @return {Node} the first-out Node to get from the queue
   */
  dequeue () {
    const oldestIndex = this.oldestIndex
    const newestIndex = this.newestIndex
    let node

    if (oldestIndex !== newestIndex) {
      node = this.storage[oldestIndex]

      delete this.storage[oldestIndex]
      this.oldestIndex++

      return node
    }
  }
}

/**
 * A class that implements the tree data type for Node objects.
 */
class Tree {
  /**
   * Create a new object of class Tree.
   *
   * @constructor
   * @constructs {Tree}
   *
   * @param {Node} root - the root Node of the tree
   */
  constructor (root) {
    root.parent = root // Allows `cd ..` any number of times
    this.root = root
  }

  /**
   * Traverse the tree using the DFT algorithm.
   * @param {function} callbackFn - the function to execute on each node
   */
  traverseDepthFirst (callbackFn) {
    (function recurse (currentNode) {
      currentNode.children.forEach(child => {
        recurse(child)
      })
      callbackFn(currentNode)
    })(this.root)
  }

  /**
   * Traverse the tree using the BFT algorithm.
   * @param {function} callbackFn - the function to execute on each node
   */
  traverseBreadthFirst (callbackFn) {
    const queue = new Queue()
    queue.enqueue(this.root)
    let currentTree = queue.dequeue()
    while (currentTree) {
      currentTree.children.forEach(child => {
        queue.enqueue(child)
      })
      callbackFn(currentTree)
      currentTree = queue.dequeue()
    }
  }

  /**
   * Traverse the tree with the given function and perform the given action
   * on all Nodes encountered during the traversal.
   * @param {function} callbackFn - the action to perform on the traversed Nodes
   * @param {function} traversalFn - the traversal function to employ
   */
  traverse (traversalFn, callbackFn) {
    traversalFn.apply(this, [callbackFn]) // Call traversal, with this as context
  }

  /**
   * Add the given Node to the tree under the Node with the specified name.
   * @param {Node} node - the Node to add to the tree
   * @param {string} parentName - the name of the Node above this one
   * @param {function} traversalFn - the traversal function to employ
   */
  add (node, parentName, traversalFn) {
    let parent = null

    this.traverse(traversalFn, (node) => {
      if (node.name === parentName) {
        parent = node
      }
    })

    if (parent) {
      parent.children.push(node)
      node.parent = parent
    } else {
      console.log(`Error occurred when adding ${node.name} to ${parentName}`)
    }
  }
}

/**
 * Create an object of class Tree using the JSON tree object.
 * @param {Object} basicTree - the JSON object to convert to a tree
 * @returns {Tree} the Tree object generated by traversing basicTree
 */
function generateTree (basicTree) {
  const node = new Node(
    basicTree.type,
    basicTree.name,
    basicTree.alternativeName
  )
  const tree = new Tree(node)

  populateTree(tree, basicTree)

  return tree
}

/**
 * Populate the object of class Tree by recursively traversing the JSON tree.
 * @param {Tree} tree - the Tree object being populated
 * @param {Object} basicNode - the current JSON node to traverse
 */
function populateTree (tree, basicNode) {
  const basicChildren = basicNode.children

  for (let i = 0; i < basicChildren.length; i++) {
    const basicChild = basicChildren[i]
    const childNode = new Node(
      basicChild.type,
      basicChild.name,
      basicChild.alternativeName
    )

    tree.add(childNode, basicNode.name, tree.traverseBreadthFirst)

    if (basicChild.type === 'folder') {
      populateTree(tree, basicChild)
    }
  }
}

export {
  generateTree
}
